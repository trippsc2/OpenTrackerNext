using System.Diagnostics.CodeAnalysis;
using System.Threading.Tasks;
using OpenTrackerNext.Roslyn.SplatRegistration;
using Xunit;

namespace OpenTrackerNext.Roslyn.UnitTests.SplatRegistration;

[ExcludeFromCodeCoverage]
public sealed class SplatRegistrationGeneratorTests
{
    [Fact]
    public async Task ShouldGenerateEmptyMethod_WhenNoRegistrationsAreMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable
            
            namespace TestProject;
            
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable
            
            namespace TestProject.Generated;
            
            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_WhenMarkedClassIsAbstract()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public abstract class TestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_WhenMarkedClassIsStatic()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public static class TestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }

    [Fact]
    public async Task ShouldGenerateRegistrationForReactiveView()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using Avalonia.ReactiveUI;
            using OpenTrackerNext.SplatRegistration;
            using ReactiveUI;

            namespace TestProject;
            
            public class TestViewModel : ReactiveObject
            {
            }

            public class TestView : ReactiveUserControl<TestViewModel>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestView(), typeof(global::ReactiveUI.IViewFor<global::TestProject.TestViewModel>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_NoRegisterAs_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public class TestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.TestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_NoRegisterAs_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public class TestClass
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.TestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_Transient_NoRegisterAs_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public class TestClass
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_NoRegisterAs_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            public class TestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.TestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInterface_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            public class TestClass : ITestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.ITestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInterface_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.ITestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInterface_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInterface_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            public class TestClass : ITestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass(), typeof(global::TestProject.ITestClass));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInterfaceNotImplemented()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            public class TestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsDelegate_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
                public delegate ITestClass Factory(int i);
            }

            [Splat(RegisterAsType = typeof(ITestClass.Factory))]
            public class TestClass : ITestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass.Factory((i) => new global::TestProject.TestClass()), typeof(global::TestProject.ITestClass.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsDelegate_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
                public delegate ITestClass Factory(int i);
            }

            [Splat(RegisterAsType = typeof(ITestClass.Factory))]
            public class TestClass : ITestClass
            {
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass.Factory((i) => new global::TestProject.TestClass(i)), typeof(global::TestProject.ITestClass.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsDelegate_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
                public delegate ITestClass Factory(int i);
            }

            [Splat(RegisterAsType = typeof(ITestClass.Factory))]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsDelegate_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
                public delegate ITestClass Factory(int i);
            }

            [Splat(RegisterAsType = typeof(ITestClass.Factory))]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
                
                [SplatConstructor]
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass.Factory((i) => new global::TestProject.TestClass(i)), typeof(global::TestProject.ITestClass.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_Transient_RegisterAsInvalidDelegate()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass
            {
                public delegate ITestClass Factory(int i);
            }

            [Splat(RegisterAsType = typeof(ITestClass.Factory))]
            public class TestClass
            {
                public TestClass()
                {
                }
                
                [SplatConstructor]
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_NoRegisterAs_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            [SplatSingleInstance]
            public class TestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_NoRegisterAs_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            [SplatSingleInstance]
            public class TestClass
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_SingleInstance_NoRegisterAs_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            [SplatSingleInstance]
            public class TestClass
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_NoRegisterAs_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [Splat]
            [SplatSingleInstance]
            public class TestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_NoRegisterAsInterface_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            [SplatSingleInstance]
            public class TestClass : ITestClass
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_RegisterAsInterface_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            [SplatSingleInstance]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_SingleInstance_RegisterAsInterface_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            [SplatSingleInstance]
            public class TestClass : ITestClass
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_Splat_NonGeneric_SingleInstance_RegisterAsInterface_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            [SplatSingleInstance]
            public class TestClass : ITestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass>(() => new global::TestProject.TestClass());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_NonGeneric_SingleInstance_RegisterAsInterfaceNotImplemented()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass
            {
            }

            [Splat(RegisterAsType = typeof(ITestClass))]
            [SplatSingleInstance]
            public class TestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }

    [Fact]
    public async Task ShouldNotGenerateRegistration_Splat_Generic()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            public class TestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.TestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.TestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_NoRegisterAs_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            public class TestClass<T>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.TestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.TestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_NoRegisterAs_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            public class TestClass<T>
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.TestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.TestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_Transient_NoRegisterAs_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            public class TestClass<T>
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_NoRegisterAs_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            public class TestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.TestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.TestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInterface_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            public class TestClass<T> : ITestClass<T>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.ITestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.ITestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInterface_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.ITestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.ITestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInterface_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInterface_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            public class TestClass<T> : ITestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.TestClass<int>(), typeof(global::TestProject.ITestClass<int>));
                    resolver.Register(() => new global::TestProject.TestClass<string>(), typeof(global::TestProject.ITestClass<string>));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInterfaceNotImplemented()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            public class TestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsDelegate_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
                public delegate ITestClass<T> Factory(int i);
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>.Factory))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>.Factory))]
            public class TestClass<T> : ITestClass<T>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass<int>.Factory((i) => new global::TestProject.TestClass<int>()), typeof(global::TestProject.ITestClass<int>.Factory));
                    resolver.Register(() => new global::TestProject.ITestClass<string>.Factory((i) => new global::TestProject.TestClass<string>()), typeof(global::TestProject.ITestClass<string>.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsDelegate_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
                public delegate ITestClass<T> Factory(int i);
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>.Factory))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>.Factory))]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass<int>.Factory((i) => new global::TestProject.TestClass<int>(i)), typeof(global::TestProject.ITestClass<int>.Factory));
                    resolver.Register(() => new global::TestProject.ITestClass<string>.Factory((i) => new global::TestProject.TestClass<string>(i)), typeof(global::TestProject.ITestClass<string>.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsDelegate_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
                public delegate ITestClass<T> Factory(int i);
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>.Factory))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>.Factory))]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsDelegate_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
                public delegate ITestClass<T> Factory(int i);
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>.Factory))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>.Factory))]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
                
                [SplatConstructor]
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    resolver.Register(() => new global::TestProject.ITestClass<int>.Factory((i) => new global::TestProject.TestClass<int>(i)), typeof(global::TestProject.ITestClass<int>.Factory));
                    resolver.Register(() => new global::TestProject.ITestClass<string>.Factory((i) => new global::TestProject.TestClass<string>(i)), typeof(global::TestProject.ITestClass<string>.Factory));
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_Transient_RegisterAsInvalidDelegate()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass<T>
            {
                public delegate ITestClass<T> Factory(int i);
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>.Factory))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>.Factory))]
            public class TestClass<T>
            {
                public TestClass()
                {
                }
                
                [SplatConstructor]
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_NoRegisterAs_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_NoRegisterAs_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T>
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_SingleInstance_NoRegisterAs_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T>
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_NoRegisterAs_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.TestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.TestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.TestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_NoRegisterAsInterface_NoConstructors()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T> : ITestClass<T>
            {
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_RegisterAsInterface_SingleConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_SingleInstance_RegisterAsInterface_ConstructorNotMarked()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T> : ITestClass<T>
            {
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldGenerateRegistration_SplatGeneric_Generic_SingleInstance_RegisterAsInterface_MarkedConstructor()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;
            
            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T> : ITestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<int>>(() => new global::TestProject.TestClass<int>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<int>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<int>));
                    }
                    {
                        var lazy = new global::System.Lazy<global::TestProject.ITestClass<string>>(() => new global::TestProject.TestClass<string>());
                        resolver.Register(() => lazy, typeof(global::System.Lazy<global::TestProject.ITestClass<string>>));
                        resolver.Register(() => lazy.Value, typeof(global::TestProject.ITestClass<string>));
                    }
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
    
    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_Generic_SingleInstance_RegisterAsInterfaceNotImplemented()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            public interface ITestClass<T>
            {
            }

            [SplatGeneric(ConcreteType = typeof(TestClass<int>), RegisterAsType = typeof(ITestClass<int>))]
            [SplatGeneric(ConcreteType = typeof(TestClass<string>), RegisterAsType = typeof(ITestClass<string>))]
            [SplatSingleInstance]
            public class TestClass<T>
            {
                [SplatConstructor]
                public TestClass()
                {
                }
                
                public TestClass(int i)
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }

    [Fact]
    public async Task ShouldNotGenerateRegistration_SplatGeneric_NonGeneric()
    {
        // lang=cs
        const string source =
            """
            #nullable enable

            using OpenTrackerNext.SplatRegistration;

            namespace TestProject;

            [SplatGeneric(ConcreteType = typeof(TestClass))]
            public class TestClass
            {
                [SplatConstructor]
                public TestClass()
                {
                }
            }
            """;
        
        // lang=cs
        const string expected =
            """
            // <auto-generated/>
            #nullable enable

            namespace TestProject.Generated;

            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFromTestProject(this global::Splat.IMutableDependencyResolver resolver)
                {
                    return resolver;
                }
            }
            """;

        await GeneratorTest<SplatRegistrationGenerator>
            .VerifyGeneratorAsync(
                source,
                (SplatRegistrationGenerator.SplatAttributeHintName, SplatRegistrationGenerator.SplatAttributeCode),
                (SplatRegistrationGenerator.SplatConstructorAttributeHintName, SplatRegistrationGenerator.SplatConstructorAttributeCode),
                (SplatRegistrationGenerator.SplatGenericAttributeHintName, SplatRegistrationGenerator.SplatGenericAttributeCode),
                (SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeHintName, SplatRegistrationGenerator.SplatIgnoreReactiveViewAttributeCode),
                (SplatRegistrationGenerator.SplatSingleInstanceAttributeHintName, SplatRegistrationGenerator.SplatSingleInstanceAttributeCode),
                ("TestProject.Generated.SplatExtensions.g.cs", expected));
    }
}