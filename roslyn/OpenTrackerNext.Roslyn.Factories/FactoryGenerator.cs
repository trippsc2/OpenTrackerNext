using System.Collections.Immutable;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OpenTrackerNext.Roslyn.Factories.Data;
using OpenTrackerNext.Roslyn.Semantic;
using OpenTrackerNext.Roslyn.Syntactic;

namespace OpenTrackerNext.Roslyn.Factories;

/// <summary>
/// Generates abstract factory source code.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class FactoryGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The hint name of the generated file for the AbstractFactoryAttribute.
    /// </summary>
    public const string AbstractFactoryAttributeHintName = "OpenTrackerNext.Factories.AbstractFactoryAttribute.g.cs";
    
    /// <summary>
    /// The hint name of the generated file for the FactoryAttribute.
    /// </summary>
    public const string FactoryAttributeHintName = "OpenTrackerNext.Factories.FactoryAttribute.g.cs";
    
    /// <summary>
    /// The source code for the AbstractFactoryAttribute.
    /// </summary>
    // lang=cs
    public const string AbstractFactoryAttributeSource =
        """
        #nullable enable
        // <auto-generated/>
        
        namespace OpenTrackerNext.Factories;
        
        /// <summary>
        /// Marks a class as an abstract factory.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class AbstractFactoryAttribute : global::System.Attribute;
        """;
    
    /// <summary>
    /// The source code for the FactoryAttribute.
    /// </summary>
    // lang=cs
    public const string FactoryAttributeSource =
        """
        #nullable enable
        // <auto-generated/>
        
        namespace OpenTrackerNext.Factories;
        
        /// <summary>
        /// Marks a class as a factory belonging to the specified abstract factory.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class FactoryAttribute : global::System.Attribute;
        """;
    
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(AbstractFactoryAttributeHintName, AbstractFactoryAttributeSource));

        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(FactoryAttributeHintName, FactoryAttributeSource));

        var specificFactories = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.Factories.FactoryAttribute",
                CouldBeSpecificFactory,
                TransformToFactoryInfo)
            .Where(x => x is not null)
            .Select((x, _) => x!.Value)
            .Collect();

        var abstractFactories = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.Factories.AbstractFactoryAttribute",
                CouldBeAbstractFactory,
                TransformToAbstractFactoryInfo)
            .Where(x => x is not null)
            .Select((x, _) => x!.Value)
            .Collect();

        var factoryImplementations = specificFactories
            .Combine(abstractFactories)
            .Select(TransformToFactoryInfo);
        
        context.RegisterSourceOutput(factoryImplementations, GenerateCode);
    }
    
    private static bool CouldBeSpecificFactory(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsPartial();
    }
    
    private static bool CouldBeAbstractFactory(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsPartial();
    }

    private static SpecificFactoryInfo? TransformToFactoryInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

        if (!classSymbol.ImplementsInterfaceNamed(
                out var specificFactoryInterface,
                "ISpecificFactory",
                "OpenTrackerNext.Core.Factories",
                3))
        {
            return null;
        }

        var typeNameFormat = new SymbolDisplayFormat(genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);

        var specificFactoryTypeQualifiedName = classSymbol.ToFullyQualifiedString();
        var specificFactoryTypeName = classSymbol.ToDisplayString(typeNameFormat);
        var specificFactoryNamespace = classSymbol.ContainingNamespace.ToDisplayString();
        var baseInputTypeName = specificFactoryInterface.TypeArguments[0].ToFullyQualifiedString();
        var outputTypeName = specificFactoryInterface.TypeArguments[1].ToFullyQualifiedString();
        var inputTypeName = specificFactoryInterface.TypeArguments[2].ToFullyQualifiedString();
        
        return new SpecificFactoryInfo(
            specificFactoryTypeQualifiedName,
            specificFactoryTypeName,
            specificFactoryNamespace,
            baseInputTypeName,
            outputTypeName,
            inputTypeName);
    }
    
    private static AbstractFactoryInfo? TransformToAbstractFactoryInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

        if (!classSymbol.ImplementsInterfaceNamed(
                out var factoryInterface,
                "IFactory",
                "OpenTrackerNext.Core.Factories",
                2))
        {
            return null;
        }

        var abstractFactoryTypeName = classSymbol.Name;
        var abstractFactoryNamespace = classSymbol.ContainingNamespace.ToDisplayString();
        var factoryInterfaceTypeName = factoryInterface.ToFullyQualifiedString();
        var baseInputTypeName = factoryInterface.TypeArguments[0].ToFullyQualifiedString();
        var outputTypeName = factoryInterface.TypeArguments[1].ToFullyQualifiedString();
        
        return new AbstractFactoryInfo(
            abstractFactoryTypeName,
            abstractFactoryNamespace,
            factoryInterfaceTypeName,
            baseInputTypeName,
            outputTypeName);
    }

    private static FactoryInfo TransformToFactoryInfo(
        (ImmutableArray<SpecificFactoryInfo> Left, ImmutableArray<AbstractFactoryInfo> Right) factories,
        CancellationToken cancellationToken)
    {
        var (allSpecificFactories, abstractFactories) = factories;

        var factoryGroupsBuilder = ImmutableArray.CreateBuilder<FactoryGroupInfo>();

        foreach (var abstractFactory in abstractFactories)
        {
            var specificFactories = GetSpecificFactoriesForAbstractFactory(
                abstractFactory,
                allSpecificFactories);

            factoryGroupsBuilder.Add(new FactoryGroupInfo(abstractFactory, specificFactories));
        }
        
        return new FactoryInfo(factoryGroupsBuilder.ToImmutable(), allSpecificFactories);
    }
    
    private static ImmutableArray<SpecificFactoryInfo> GetSpecificFactoriesForAbstractFactory(
        AbstractFactoryInfo abstractFactory,
        ImmutableArray<SpecificFactoryInfo> allSpecificFactories)
    {
        var builder = ImmutableArray.CreateBuilder<SpecificFactoryInfo>();

        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var specificFactory in allSpecificFactories)
        {
            if (abstractFactory.BaseInputTypeName == specificFactory.BaseInputTypeName &&
                abstractFactory.OutputTypeName == specificFactory.OutputTypeName)
            {
                builder.Add(specificFactory);
            }
        }
        
        return builder.ToImmutable();
    }

    private static void GenerateCode(SourceProductionContext context, FactoryInfo factoryInfo)
    {
        foreach (var specificFactory in factoryInfo.SpecificFactories)
        {
            GenerateSpecificFactoryCode(context, specificFactory);
        }
        
        foreach (var factoryGroup in factoryInfo.FactoryGroups)
        {
            GenerateAbstractFactoryCode(context, factoryGroup);
        }
    }
    
    private static void GenerateSpecificFactoryCode(
        SourceProductionContext context,
        SpecificFactoryInfo specificFactory)
    {
        var nameWithoutAngleBrackets = specificFactory.SpecificFactoryTypeName
            .Replace("<", string.Empty)
            .Replace(">", string.Empty);
        
        var hintName = $"{specificFactory.SpecificFactoryTypeNamespace}.{nameWithoutAngleBrackets}.g.cs";
        
        // lang=cs
        var source =
            $$"""
              #nullable enable
              // <auto-generated/>

              namespace {{specificFactory.SpecificFactoryTypeNamespace}};

              partial class {{specificFactory.SpecificFactoryTypeName}}
              {
                  {{specificFactory.OutputTypeName}} global::OpenTrackerNext.Core.Factories.IFactory<{{specificFactory.BaseInputTypeName}}, {{specificFactory.OutputTypeName}}>.Create({{specificFactory.BaseInputTypeName}} input)
                  {
                      if (input is not {{specificFactory.InputTypeName}} specificInput)
                      {
                          throw new global::System.ArgumentException("Input is not of the correct type.");
                      }
                      
                      return Create(specificInput);
                  }
              }
              """;
        
        context.AddSource(hintName, source);
    }

    private static void GenerateAbstractFactoryCode(
        SourceProductionContext context,
        FactoryGroupInfo factoryGroup)
    {
            var abstractFactoryInfo = factoryGroup.AbstractFactoryInfo;
            
            var nameWithoutAngleBrackets = abstractFactoryInfo.AbstractFactoryTypeName
                .Replace("<", string.Empty)
                .Replace(">", string.Empty);

            var hintName = $"{abstractFactoryInfo.AbstractFactoryNamespace}.{nameWithoutAngleBrackets}.g.cs";
            
            // lang=cs
            var header =
                $$"""
                #nullable enable
                // <auto-generated/>
                
                namespace {{abstractFactoryInfo.AbstractFactoryNamespace}};

                partial class {{abstractFactoryInfo.AbstractFactoryTypeName}}
                {
                    private readonly global::System.Collections.Immutable.ImmutableDictionary<global::System.Type, {{abstractFactoryInfo.FactoryInterfaceTypeName}}> _factories;
                    
                    public {{abstractFactoryInfo.AbstractFactoryTypeName}}()
                    {
                        _factories = GetFactories();
                    }
                    
                    public {{abstractFactoryInfo.OutputTypeName}} Create({{abstractFactoryInfo.BaseInputTypeName}} input)
                    {
                        return _factories[input.GetType()].Create(input);
                    }
                    
                    private global::System.Collections.Immutable.ImmutableDictionary<global::System.Type, {{abstractFactoryInfo.FactoryInterfaceTypeName}}> GetFactories()
                    {
                        var builder = global::System.Collections.Immutable.ImmutableDictionary.CreateBuilder<global::System.Type, {{abstractFactoryInfo.FactoryInterfaceTypeName}}>();
                        
                
                """;
            
            var stringBuilder = new StringBuilder(header);

            foreach (var factory in factoryGroup.SpecificFactories)
            {
                // lang=cs
                var factoryRegistration =
                    $"""
                            builder.Add(typeof({factory.InputTypeName}), ({abstractFactoryInfo.FactoryInterfaceTypeName})global::Splat.Locator.Current.GetService(typeof({factory.SpecificFactoryTypeQualifiedName}))!);

                    """;
                
                stringBuilder.Append(factoryRegistration);
            }

            // lang=cs
            const string footer =
                """
                    
                        return builder.ToImmutable();
                    }
                }
                """;
            
            stringBuilder.Append(footer);
            
            context.AddSource(hintName, stringBuilder.ToString());
    }
}