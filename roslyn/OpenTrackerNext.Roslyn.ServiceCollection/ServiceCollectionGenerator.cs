using System.Collections.Immutable;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OpenTrackerNext.Roslyn.Semantic;
using OpenTrackerNext.Roslyn.ServiceCollection.Data;
using OpenTrackerNext.Roslyn.Syntactic;

namespace OpenTrackerNext.Roslyn.ServiceCollection;

/// <summary>
/// Generates service collections.
/// </summary>
[Generator]
public sealed class ServiceCollectionGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The hint name of the ServiceCollectionAttribute class.
    /// </summary>
    public const string ServiceCollectionAttributeHintName =
        "OpenTrackerNext.ServiceCollection.ServiceCollectionAttribute.g.cs";
    
    /// <summary>
    /// The hint name of the ServiceCollectionMemberAttribute{TCollection} class.
    /// </summary>
    public const string ServiceCollectionMemberAttributeHintName =
        "OpenTrackerNext.ServiceCollection.ServiceCollectionMemberAttribute.TCollection.g.cs";

    /// <summary>
    /// The source code of the ServiceCollectionAttribute class.
    /// </summary>
    // lang=cs
    public const string ServiceCollectionAttributeSource =
        """
        #nullable enable
        // <auto-generated/>
        
        namespace OpenTrackerNext.ServiceCollection;
        
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class ServiceCollectionAttribute : global::System.Attribute;
        
        """;
    
    /// <summary>
    /// The source code of the ServiceCollectionMemberAttribute{TCollection} class.
    /// </summary>
    // lang=cs
    public const string ServiceCollectionMemberAttributeSource =
        """
        #nullable enable
        // <auto-generated/>
        
        namespace OpenTrackerNext.ServiceCollection;
        
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class ServiceCollectionMemberAttribute<TCollection> : global::System.Attribute
            where TCollection : class;
        
        """;
    
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(ServiceCollectionAttributeHintName, ServiceCollectionAttributeSource));

        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(ServiceCollectionMemberAttributeHintName, ServiceCollectionMemberAttributeSource));

        var serviceCollections = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.ServiceCollection.ServiceCollectionAttribute",
                CouldBeServiceCollection,
                TransformServiceCollection)
            .Where(x => x is not null)
            .Select((x, _) => x!.Value)
            .Collect();
        
        var serviceCollectionMembers = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.ServiceCollection.ServiceCollectionMemberAttribute`1",
                CouldBeServiceCollectionMember,
                TransformServiceCollectionMember)
            .Where(x => x is not null)
            .Select((x, _) => x!.Value)
            .Collect();

        var serviceCollectionImplementations = serviceCollections
            .Combine(serviceCollectionMembers)
            .Select(TransformServiceCollectionImplementations);

        context.RegisterSourceOutput(serviceCollectionImplementations, GenerateCode);
    }
    
    private static bool CouldBeServiceCollection(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsPartial();
    }

    private static bool CouldBeServiceCollectionMember(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic();
    }
    
    private static ServiceCollectionInfo? TransformServiceCollection(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

        if (!classSymbol.ImplementsInterfaceNamed(
                out var serviceCollectionInterfaceSymbol,
                "IServiceCollection",
                "OpenTrackerNext.Core.Utils",
                1))
        {
            return null;
        }
        
        var serviceTypeSymbol = (INamedTypeSymbol)serviceCollectionInterfaceSymbol.TypeArguments[0];
        
        return new ServiceCollectionInfo(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            serviceTypeSymbol.Name,
            serviceTypeSymbol.ContainingNamespace.ToDisplayString());
    }
    
    private static ServiceCollectionMemberInfo? TransformServiceCollectionMember(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;
        var attribute = context.Attributes[0];

        var registerAsTypeSymbol = classSymbol;

        if (classSymbol.HasAttribute(
                out var splatAttribute,
                "SplatAttribute",
                "OpenTrackerNext.SplatRegistration"))
        {
            registerAsTypeSymbol = splatAttribute
                .GetNamedArgumentReferenceType(
                    "RegisterAsType",
                    registerAsTypeSymbol);
        }
        
        if (attribute.AttributeClass?.TypeArguments[0] is not INamedTypeSymbol serviceCollectionTypeSymbol)
        {
            return null;
        }
        
        if (!serviceCollectionTypeSymbol.ImplementsInterfaceNamed(
                out var serviceCollectionInterfaceSymbol,
                "IServiceCollection",
                "OpenTrackerNext.Core.Utils",
                1))
        {
            return null;
        }
        
        var serviceTypeSymbol = (INamedTypeSymbol)serviceCollectionInterfaceSymbol.TypeArguments[0];

        if (!classSymbol.InheritsFromOrImplements(serviceTypeSymbol))
        {
            return null;
        }
        
        return new ServiceCollectionMemberInfo(
            new ServiceCollectionMemberTypeInfo(
                classSymbol.ToFullyQualifiedString(),
                registerAsTypeSymbol!.ToFullyQualifiedString()),
            new ServiceCollectionInfo(
                serviceCollectionTypeSymbol.ContainingNamespace.ToDisplayString(),
                serviceCollectionTypeSymbol.Name,
                serviceTypeSymbol.Name,
                serviceTypeSymbol.ContainingNamespace.ToDisplayString()));
    }
    
    private static ImmutableArray<ServiceCollectionImplementationInfo> TransformServiceCollectionImplementations(
        (ImmutableArray<ServiceCollectionInfo> Left, ImmutableArray<ServiceCollectionMemberInfo> Right) collectionInfo,
        CancellationToken cancellationToken)
    {
        var (serviceCollections, serviceCollectionMembers) = collectionInfo;

        var implementationsBuilder = ImmutableArray.CreateBuilder<ServiceCollectionImplementationInfo>();

        foreach (var serviceCollection in serviceCollections)
        {
            var collectionMembersBuilder = ImmutableArray.CreateBuilder<ServiceCollectionMemberTypeInfo>();
            
            foreach (var serviceCollectionMember in serviceCollectionMembers)
            {
                if (serviceCollectionMember.CollectionInfo == serviceCollection)
                {
                    collectionMembersBuilder.Add(serviceCollectionMember.TypeInfo);
                }
            }
            
            implementationsBuilder.Add(
                new ServiceCollectionImplementationInfo(
                    serviceCollection,
                    collectionMembersBuilder.ToImmutable()));
        }
        
        return implementationsBuilder.ToImmutable();
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ServiceCollectionImplementationInfo> implementations)
    {
        foreach (var implementation in implementations)
        {
            GenerateImplementation(context, implementation);
        }
    }
    
    private static void GenerateImplementation(
        SourceProductionContext context,
        ServiceCollectionImplementationInfo implementation)
    {
        var serviceCollectionInfo = implementation.ServiceCollectionInfo;
        var memberTypesInfo = implementation.MemberTypesInfo;
        
        var hintName = $"{serviceCollectionInfo.NamespaceName}.{serviceCollectionInfo.TypeName}.g.cs";

        var qualifiedServiceName =
            $"global::{serviceCollectionInfo.ServiceTypeNamespaceName}.{serviceCollectionInfo.ServiceTypeName}";
        
        // lang=cs
        var header =
            $$"""
            // <auto-generated/>
            #nullable enable
            
            namespace {{serviceCollectionInfo.NamespaceName}};
            
            partial class {{serviceCollectionInfo.TypeName}}
            {
                public global::System.Collections.Generic.IReadOnlyList<{{qualifiedServiceName}}> All { get; } = new global::System.Collections.Generic.List<{{qualifiedServiceName}}>
                {
            
            """;

        var stringBuilder = new StringBuilder(header);

        foreach (var memberTypeInfo in memberTypesInfo)
        {
            // lang=cs
            stringBuilder
                .AppendLine(
                    $"        ({qualifiedServiceName})global::Splat.Locator.Current.GetService(typeof({memberTypeInfo.RegisteredAsTypeQualifiedName}))!,");
        }
        
        // lang=cs
        const string footer =
            """
                };
            }
            """;
        
        stringBuilder.Append(footer);
        
        context.AddSource(hintName, stringBuilder.ToString());
    }
}