using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OpenTrackerNext.Roslyn.Document.Data;
using OpenTrackerNext.Roslyn.Semantic;
using OpenTrackerNext.Roslyn.Syntactic;

namespace OpenTrackerNext.Roslyn.Document;

/// <summary>
/// Generates the source code to implement value equality for classes marked with DocumentAttribute.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DocumentGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The hint name for the DocumentAttribute source code.
    /// </summary>
    public const string DocumentAttributeHintName = "OpenTrackerNext.Document.DocumentAttribute.g.cs";

    /// <summary>
    /// The hint name for the DocumentMemberAttribute source code.
    /// </summary>
    public const string DocumentMemberAttributeHintName = "OpenTrackerNext.Document.DocumentMemberAttribute.g.cs";
    
    /// <summary>
    /// The hint name for the ObservableCollectionExtensions source code.
    /// </summary>
    public const string ObservableCollectionExtensionsHintName = "OpenTrackerNext.Document.ObservableCollectionExtensions.g.cs";

    /// <summary>
    /// The source code for the DocumentAttribute class.
    /// </summary>
    // lang=cs
    public const string DocumentAttributeSource =
        """
        // <auto-generated />
        #nullable enable
        
        namespace OpenTrackerNext.Document;
        
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class DocumentAttribute : global::System.Attribute;
        
        """;

    /// <summary>
    /// The source code for the DocumentMemberAttribute class.
    /// </summary>
    // lang=cs
    public const string DocumentMemberAttributeSource =
        """
        // <auto-generated />
        #nullable enable

        namespace OpenTrackerNext.Document;

        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
        internal sealed class DocumentMemberAttribute : global::System.Attribute;
        
        """;
    
    /// <summary>
    /// The source code for the ObservableCollectionExtensions class.
    /// </summary>
    // lang=cs
    public const string ObservableCollectionExtensionsSource =
        """
        // <auto-generated />
        #nullable enable

        namespace OpenTrackerNext.Document;

        internal static class ObservableCollectionExtensions
        {
            internal static bool SequenceValueEqual<T>(this global::System.Collections.ObjectModel.ObservableCollection<T> self, global::System.Collections.ObjectModel.ObservableCollection<T> other)
                where T : global::OpenTrackerNext.Core.Equality.IValueEquatable
            {
                if (self.Count != other.Count)
                {
                    return false;
                }

                return !global::System.Linq.Enumerable.Any(global::System.Linq.Enumerable.Where(self, (member, i) => !member.ValueEquals(other[i])), _ => true);
            }
        }
        """;
    
    private static readonly ImmutableArray<string> KnownImmutableReferenceTypes =
        [$"{typeof(Version).Namespace}.{nameof(Version)}"];

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(DocumentAttributeHintName, DocumentAttributeSource));

        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(DocumentMemberAttributeHintName, DocumentMemberAttributeSource));

        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(ObservableCollectionExtensionsHintName, ObservableCollectionExtensionsSource));

        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.Document.DocumentAttribute",
                (node, _) => CouldBeMarkedClass(node),
                TransformMarkedClass)
            .Where(x => x is not null)
            .Select((x, _) => x!.Value)
            .Collect()
            .Combine(context.CompilationProvider.Select((x, _) => x.AssemblyName!))
            .Select((x, _) => new DocumentAssemblyInfo(x.Right, x.Left));

        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static bool CouldBeMarkedClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsPartial() &&
               classDeclaration.IsNotStatic();
    }

    private static DocumentTypeInfo? TransformMarkedClass(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }
        
        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classSymbol.ContainingNamespace.ToDisplayString();

        var nameFormat = new SymbolDisplayFormat(genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);
        
        var className = classSymbol.ToDisplayString(nameFormat);

        var taggedWithIDocumentData = classSymbol
            .ImplementsInterfaceNamed(
                out _,
                "IDocumentData",
                "OpenTrackerNext.Core.Documents",
                1);
        
        var propertySymbols = classSymbol.GetMembers()
            .Where(symbol => symbol.Kind == SymbolKind.Property)
            .Cast<IPropertySymbol>()
            .Where(symbol => !symbol.IsReadOnly)
            .ToList();
        
        var fieldSymbols = classSymbol.GetMembers()
            .Where(symbol => symbol.Kind == SymbolKind.Field)
            .Cast<IFieldSymbol>()
            .Where(
                symbol =>
                    !symbol.IsReadOnly ||
                    symbol.HasAttribute(
                        out _,
                        "ReactivePropertyAttribute",
                        "OpenTrackerNext.Reactive"))
            .ToList();
        
        var propertyBuilder = ImmutableArray.CreateBuilder<DocumentPropertyInfo>();
        
        TransformProperties(propertyBuilder, propertySymbols);
        TransformFields(propertyBuilder, fieldSymbols);

        var properties = propertyBuilder.ToImmutable();
        
        return new DocumentTypeInfo(
                false,
                namespaceName,
                className,
                taggedWithIDocumentData,
                properties);
    }

    private static void TransformProperties(
        ImmutableArray<DocumentPropertyInfo>.Builder builder,
        IEnumerable<IPropertySymbol> propertySymbols)
    {
        foreach (var symbol in propertySymbols)
        {
            if (symbol.IsStatic)
            {
                continue;
            }

            if (!symbol.HasAttribute(
                    out _,
                    "DocumentMemberAttribute",
                    "OpenTrackerNext.Document"))
            {
                continue;
            }

            var type = symbol.Type;
            var namedTypeSymbol = type as INamedTypeSymbol;
            var typeParameterSymbol = type as ITypeParameterSymbol;
            
            if (namedTypeSymbol is null && typeParameterSymbol is null)
            {
                continue;
            }
            
            var isObservableCollection = namedTypeSymbol?
                .IsTypeWithName(
                    "ObservableCollection",
                    typeof(ObservableCollection<>).Namespace,
                    1)
                ?? false;

            if (isObservableCollection) 
            {
                type = namedTypeSymbol?.TypeArguments[0];
                typeParameterSymbol = namedTypeSymbol?.TypeArguments[0] as ITypeParameterSymbol;
                namedTypeSymbol = namedTypeSymbol?.TypeArguments[0] as INamedTypeSymbol;
                
                if (typeParameterSymbol is null && namedTypeSymbol is null)
                {
                    continue;
                }
            }

            var isValueTypeOrImmutableReference = (type?.IsValueType ?? false) || 
                                                  (type?.IsRecord ?? false) ||
                                                  type?.SpecialType == SpecialType.System_String;

            if (!isValueTypeOrImmutableReference)
            {
                isValueTypeOrImmutableReference = Enumerable.Any(
                    KnownImmutableReferenceTypes,
                    knownImmutableReferenceType =>
                        type?.ToDisplayString() == knownImmutableReferenceType);
            }
            
            if (!isValueTypeOrImmutableReference)
            {
                isValueTypeOrImmutableReference = type?
                    .ImplementsInterfaceNamed(
                        out _,
                        "ISmartEnum",
                        "Ardalis.SmartEnum")
                            ?? false;
            }

            var isNullableReferenceType = type is
            {
                IsReferenceType: true,
                NullableAnnotation: NullableAnnotation.Annotated
            };

            builder.Add(
                new DocumentPropertyInfo(
                    type!.ToFullyQualifiedString(),
                    symbol.Name,
                    isObservableCollection,
                    isValueTypeOrImmutableReference,
                    isNullableReferenceType));
        }
    }

    private static void TransformFields(
        ImmutableArray<DocumentPropertyInfo>.Builder builder,
        List<IFieldSymbol> fieldSymbols)
    {
        foreach (var symbol in fieldSymbols)
        {
            if (symbol.IsStatic)
            {
                continue;
            }

            if (!symbol.HasAttribute(
                    out _,
                    "DocumentMemberAttribute",
                    "OpenTrackerNext.Document"))
            {
                continue;
            }

            if (!symbol.HasAttribute(
                    out _,
                    "ReactivePropertyAttribute",
                    "OpenTrackerNext.Reactive"))
            {
                continue;
            }

            var name = ConvertFieldNameToPropertyName(symbol.Name);
            var type = symbol.Type;
            var namedTypeSymbol = type as INamedTypeSymbol;
            var typeParameterSymbol = type as ITypeParameterSymbol;
            
            if (namedTypeSymbol is null && typeParameterSymbol is null)
            {
                continue;
            }
            
            var isObservableCollection = namedTypeSymbol?
                .IsTypeWithName(
                    "ObservableCollection",
                    typeof(ObservableCollection<>).Namespace,
                    1)
                ?? false;

            if (isObservableCollection) 
            {
                type = namedTypeSymbol?.TypeArguments[0];
                typeParameterSymbol = namedTypeSymbol?.TypeArguments[0] as ITypeParameterSymbol;
                namedTypeSymbol = namedTypeSymbol?.TypeArguments[0] as INamedTypeSymbol;
                
                if (typeParameterSymbol is null && namedTypeSymbol is null)
                {
                    continue;
                }
            }

            var isValueTypeOrImmutableReference = (type?.IsValueType ?? false) || 
                                                  (type?.IsRecord ?? false) ||
                                                  type?.SpecialType == SpecialType.System_String;

            if (!isValueTypeOrImmutableReference)
            {
                isValueTypeOrImmutableReference = Enumerable.Any(
                    KnownImmutableReferenceTypes,
                    knownImmutableReferenceType =>
                        type?.ToDisplayString() == knownImmutableReferenceType);
            }
            
            if (!isValueTypeOrImmutableReference)
            {
                isValueTypeOrImmutableReference = type?
                    .ImplementsInterfaceNamed(
                        out _,
                        "ISmartEnum",
                        "Ardalis.SmartEnum")
                            ?? false;
            }

            var isNullableReferenceType = type is
            {
                IsReferenceType: true,
                NullableAnnotation: NullableAnnotation.Annotated
            };

            builder.Add(
                new DocumentPropertyInfo(
                    type!.ToFullyQualifiedString(),
                    name,
                    isObservableCollection,
                    isValueTypeOrImmutableReference,
                    isNullableReferenceType));
        }
    }

    private static string ConvertFieldNameToPropertyName(string fieldName)
    {
        var fieldNameWithoutUnderscore = fieldName[1..];
        
        return fieldNameWithoutUnderscore[0].ToString().ToUpper() + fieldNameWithoutUnderscore[1..];
    }

    private static void GenerateCode(SourceProductionContext context, DocumentAssemblyInfo documentAssemblyInfo)
    {
        foreach (var documentTypeInfo in documentAssemblyInfo.Classes)
        {
            if (documentTypeInfo.ImplementAsExtensionMethod)
            {
                GenerateDocumentExtensionMethodCode(context, documentTypeInfo, documentAssemblyInfo.AssemblyName);
                continue;
            }
            
            GenerateDocumentClassSourceCode(context, documentTypeInfo);
        }
    }
    
    private static void GenerateDocumentExtensionMethodCode(
        SourceProductionContext context,
        DocumentTypeInfo documentTypeInfo,
        string assemblyName)
    {
        var namespaceWithoutPeriods = documentTypeInfo.NamespaceName?.Replace(".", string.Empty);
        var namespacePrefix = documentTypeInfo.NamespaceName is not null
            ? $"{documentTypeInfo.NamespaceName}."
            : string.Empty;
        
        var hintName = $"{assemblyName}.Generated.{namespaceWithoutPeriods}{documentTypeInfo.ClassName}Extensions.g.cs";
        
        // lang=cs
        var header =
            $$"""
            // <auto-generated/>
            #nullable enable
            
            namespace OpenTrackerNext.Document;
            
            internal static partial class {{namespaceWithoutPeriods}}{{documentTypeInfo.ClassName}}Extensions
            {
            
            """;
        
        var stringBuilder = new StringBuilder(header);

        // lang=cs
        var makeValueEqualTo =
            $$"""
                internal static void MakeValueEqualTo(this global::{{namespacePrefix}}{{documentTypeInfo.ClassName}} self, {{documentTypeInfo.ClassName}} other)
                {
                    if (ReferenceEquals(self, other))
                    {
                        return;
                    }{{GenerateMakeValueEqualToStatements(documentTypeInfo.Properties, "self")}}
                }
            
            """;
        
        stringBuilder.Append(makeValueEqualTo);

        // lang=cs
        var clone =
            $$"""
                internal static global::{{namespacePrefix}}{{documentTypeInfo.ClassName}} Clone(this global::{{namespacePrefix}}{{documentTypeInfo.ClassName}} self)
                {
                    var clone = new global::{{namespacePrefix}}{{documentTypeInfo.ClassName}}();
                    
                    clone.MakeValueEqualTo(self);
                    
                    return clone;
                }
            
            """;
        
        stringBuilder.Append(clone);

        // lang=cs
        var valueEquals =
            $$"""
                internal static bool ValueEquals(this {{namespacePrefix}}{{documentTypeInfo.ClassName}} self, object? otherData)
                {
                    if (otherData is null)
                    {
                        return false;
                    }
                    
                    if (ReferenceEquals(self, otherData))
                    {
                        return true;
                    }
                    
                    if (otherData is not {{namespacePrefix}}{{documentTypeInfo.ClassName}} other)
                    {
                        return false;
                    }
            
                    return {{GenerateValueEqualsStatements(documentTypeInfo.Properties, "self")}};
                }
            
            """;
        
        stringBuilder.Append(valueEquals);
        
        const string footer = "}";
        
        stringBuilder.Append(footer);
        
        context.AddSource(hintName, stringBuilder.ToString());
    }
    
    private static void GenerateDocumentClassSourceCode(
        SourceProductionContext context,
        DocumentTypeInfo documentTypeInfo)
    {
        var classNameWithoutAngleBrackets = documentTypeInfo.ClassName
            .Replace("<", string.Empty)
            .Replace(">", string.Empty);
        
        var qualifiedClassName = documentTypeInfo.NamespaceName is not null
            ? $"{documentTypeInfo.NamespaceName}.{documentTypeInfo.ClassName}"
            : documentTypeInfo.ClassName;
        
        var hintName = documentTypeInfo.NamespaceName is not null
            ? $"{documentTypeInfo.NamespaceName}.{classNameWithoutAngleBrackets}.g.cs"
            : $"{classNameWithoutAngleBrackets}.g.cs";

        var interfaceDeclarations = new List<string>();
        
        if (!documentTypeInfo.TaggedWithIDocumentData)
        {
            interfaceDeclarations.Add($"global::OpenTrackerNext.Core.Documents.IDocumentData<{qualifiedClassName}>");
        }
        
        var interfaceDeclaration = interfaceDeclarations.Count > 0
            ? $" : {string.Join(", ", interfaceDeclarations)}"
            : string.Empty;

        var makeValueEqualToStatements = GenerateMakeValueEqualToStatements(
            documentTypeInfo.Properties,
            "this");
        
        // lang=cs
        var code =
            $$"""
            // <auto-generated/>
            #nullable enable
            
            using OpenTrackerNext.Document;
            
            namespace {{documentTypeInfo.NamespaceName}};
            
            partial class {{documentTypeInfo.ClassName}}{{interfaceDeclaration}}
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="{{documentTypeInfo.ClassName}}"/> class.
                /// </summary>
                public {{ConvertClassNameToConstructorName(documentTypeInfo.ClassName)}}()
                {{{GenerateConstructorStatements(documentTypeInfo)}}
                }
                
                /// <inheritdoc/>
                public global::System.IObservable<global::System.Reactive.Unit> DocumentChanges { get; }
                
                public void MakeValueEqualTo({{documentTypeInfo.ClassName}} other)
                {
                    if (ReferenceEquals(this, other))
                    {
                        return;
                    }{{makeValueEqualToStatements}}
                }
            
                bool global::OpenTrackerNext.Core.Equality.IMakeValueEqual.MakeValueEqualTo(object other)
                {
                    if (other is not {{documentTypeInfo.ClassName}} otherData)
                    {
                        return false;
                    }
            
                    MakeValueEqualTo(otherData);
                    return true;
                }
                
                public {{documentTypeInfo.ClassName}} Clone()
                {
                    var clone = new {{documentTypeInfo.ClassName}}();
                    
                    clone.MakeValueEqualTo(this);
                    
                    return clone;
                }
                
                object global::{{typeof(ICloneable).Namespace}}.{{nameof(ICloneable)}}.Clone()
                {
                    return Clone();
                }
                
                public bool ValueEquals({{documentTypeInfo.ClassName}} other)
                {
                    return {{GenerateValueEqualsStatements(documentTypeInfo.Properties, "this")}};
                }
                
                bool global::OpenTrackerNext.Core.Equality.IValueEquatable.ValueEquals(object? other)
                {
                    if (other is null)
                    {
                        return false;
                    }
                    
                    if (ReferenceEquals(this, other))
                    {
                        return true;
                    }
                    
                    if (other is not {{documentTypeInfo.ClassName}} otherData)
                    {
                        return false;
                    }
            
                    return ValueEquals(otherData);
                }
            }
            """;
        
        context.AddSource(hintName, code);
    }

    private static string ConvertClassNameToConstructorName(string className)
    {
        if (!className.Contains('<'))
        {
            return className;
        }

        var index = className.IndexOf('<');
        return className[..index];
    }

    private static string GenerateConstructorStatements(DocumentTypeInfo typeInfo)
    {
        var observableCollections = typeInfo
            .Properties
            .Where(property => property.IsObservableCollection)
            .ToList();
        
        var referenceTypes = typeInfo
            .Properties
            .Where(property => property is { IsValueTypeOrImmutableReference: false, IsObservableCollection: false })
            .ToList();
        
        if (observableCollections.Count == 0 && referenceTypes.Count == 0)
        {
            // lang=cs
            return
                """
                
                        DocumentChanges = global::System.Reactive.Linq.Observable.Select(Changed, _ => global::System.Reactive.Unit.Default);
                """;
        }
        
        // lang=cs
        var stringBuilder = new StringBuilder(
            """
            
                    var changes = global::System.Reactive.Linq.Observable.Select(Changed, _ => global::System.Reactive.Unit.Default);
                
            
            """);

        foreach (var observableCollection in observableCollections)
        {
            // lang=cs
            stringBuilder.Append(
                $"""
                        var {observableCollection.PropertyName}Changes = global::System.Reactive.Linq.Observable.Select(global::DynamicData.Binding.ObservableCollectionEx.ToObservableChangeSet({observableCollection.PropertyName}), _ => global::System.Reactive.Unit.Default);
                        var {observableCollection.PropertyName}ItemChanges = global::DynamicData.ObservableListEx.MergeMany(global::DynamicData.Binding.ObservableCollectionEx.ToObservableChangeSet({observableCollection.PropertyName}), x => x.DocumentChanges);
                        
                        changes = global::System.Reactive.Linq.Observable.Merge(changes, {observableCollection.PropertyName}Changes);
                        changes = global::System.Reactive.Linq.Observable.Merge(changes, {observableCollection.PropertyName}ItemChanges);
                
                
                """);
        }

        foreach (var referenceType in referenceTypes)
        {
            // lang=cs
            stringBuilder.Append(
                $"""
                        var {referenceType.PropertyName}Changes = global::ReactiveUI.WhenAnyObservableMixin.WhenAnyObservable(this, x => x.{referenceType.PropertyName}.DocumentChanges);
                
                        changes = global::System.Reactive.Linq.Observable.Merge(changes, {referenceType.PropertyName}Changes);
                
                
                """);
        }
        
        // lang=cs
        stringBuilder.Append("        DocumentChanges = changes;");
        
        return stringBuilder.ToString();
    }
    
    private static string GenerateMakeValueEqualToStatements(
        ImmutableArray<DocumentPropertyInfo> properties,
        string selfStatement)
    {
        if (properties.IsEmpty)
        {
            return string.Empty;
        }

        var stringBuilder = new StringBuilder("\n\n");

        for (var i = 0; i < properties.Length; i++)
        {
            var propertyInfo = properties[i];
            
            if (i < properties.Length - 1)
            {
                stringBuilder.AppendLine(GenerateMakeValueEqualToStatement(propertyInfo, selfStatement));
                continue;
            }
            
            stringBuilder.Append(GenerateMakeValueEqualToStatement(propertyInfo, selfStatement));
        }

        return stringBuilder.ToString();
    }

    private static string GenerateMakeValueEqualToStatement(DocumentPropertyInfo propertyInfo, string selfStatement)
    {
        if (propertyInfo.IsObservableCollection)
        {
            return GenerateMakeValueEqualToStatementForObservableCollection(propertyInfo, selfStatement);
        }

        if (propertyInfo.IsValueTypeOrImmutableReference)
        {
            return $"        {selfStatement}.{propertyInfo.PropertyName} = other.{propertyInfo.PropertyName};";
        }

        // ReSharper disable once ConvertIfStatementToReturnStatement
        if (propertyInfo.IsNullableReferenceType)
        {
            return $$"""
                            if (other.{{propertyInfo.PropertyName}} is null)
                            {
                                {{selfStatement}}.{{propertyInfo.PropertyName}} = null;
                            }
                            else if ({{selfStatement}}.{{propertyInfo.PropertyName}} is null)
                            {
                                {{selfStatement}}.{{propertyInfo.PropertyName}} = ({{propertyInfo.PropertyTypeName}})other.{{propertyInfo.PropertyName}}.Clone();
                            }
                            else if ({{selfStatement}}.{{propertyInfo.PropertyName}}.GetType() != other.{{propertyInfo.PropertyName}}.GetType())
                            {
                                {{selfStatement}}.{{propertyInfo.PropertyName}} = ({{propertyInfo.PropertyTypeName}})other.{{propertyInfo.PropertyName}}.Clone();
                            }
                            else
                            {
                                {{selfStatement}}.{{propertyInfo.PropertyName}}.MakeValueEqualTo(other.{{propertyInfo.PropertyName}});
                            }
                    """;
        }

        return $$"""
                         if ({{selfStatement}}.{{propertyInfo.PropertyName}}.GetType() != other.{{propertyInfo.PropertyName}}.GetType())
                         {
                             {{selfStatement}}.{{propertyInfo.PropertyName}} = ({{propertyInfo.PropertyTypeName}})other.{{propertyInfo.PropertyName}}.Clone();
                         }
                         else
                         {
                             {{selfStatement}}.{{propertyInfo.PropertyName}}.MakeValueEqualTo(other.{{propertyInfo.PropertyName}});
                         }
                 """;
    }

    private static string GenerateMakeValueEqualToStatementForObservableCollection(
        DocumentPropertyInfo propertyInfo,
        string selfStatement)
    {
        // lang=cs
        var removeExtraMembers =
            $$"""
                    while ({{selfStatement}}.{{propertyInfo.PropertyName}}.Count > other.{{propertyInfo.PropertyName}}.Count)
                    {
                        {{selfStatement}}.{{propertyInfo.PropertyName}}.RemoveAt({{selfStatement}}.{{propertyInfo.PropertyName}}.Count - 1);
                    }
            
            """;

        var stringBuilder = new StringBuilder(removeExtraMembers);
        
        var addStatement = propertyInfo.IsValueTypeOrImmutableReference
            ? $"{selfStatement}.{propertyInfo.PropertyName}.Add(other.{propertyInfo.PropertyName}[{selfStatement}.{propertyInfo.PropertyName}.Count]);"
            : propertyInfo.IsNullableReferenceType
                ? $"{selfStatement}.{propertyInfo.PropertyName}.Add(({propertyInfo.PropertyTypeName}?)other.{propertyInfo.PropertyName}[{selfStatement}.{propertyInfo.PropertyName}.Count]?.Clone());"
                : $"{selfStatement}.{propertyInfo.PropertyName}.Add(({propertyInfo.PropertyTypeName})other.{propertyInfo.PropertyName}[{selfStatement}.{propertyInfo.PropertyName}.Count].Clone());";
        
        // lang=cs
        var addMissingMembers =
            $$"""
                    while ({{selfStatement}}.{{propertyInfo.PropertyName}}.Count < other.{{propertyInfo.PropertyName}}.Count)
                    {
                        {{addStatement}}
                    }
            
            """;
        
        stringBuilder.Append(addMissingMembers);
        
        var loopStatement = propertyInfo.IsValueTypeOrImmutableReference
            ? $"{selfStatement}.{propertyInfo.PropertyName}[i] = other.{propertyInfo.PropertyName}[i];"
            : propertyInfo.IsNullableReferenceType
                ? $$"""
                    if ({{selfStatement}}.{{propertyInfo.PropertyName}}[i] is null)
                                {
                                    {{selfStatement}}.{{propertyInfo.PropertyName}}[i] = ({{propertyInfo.PropertyTypeName}}?)other.{{propertyInfo.PropertyName}}[i]?.Clone();
                                }
                                else if (other.{{propertyInfo.PropertyName}}[i] is null)
                                {
                                    {{selfStatement}}.{{propertyInfo.PropertyName}}[i] = null;
                                }
                                else if ({{selfStatement}}.{{propertyInfo.PropertyName}}[i]!.GetType() != other.{{propertyInfo.PropertyName}}[i]!.GetType())
                                {
                                    {{selfStatement}}.{{propertyInfo.PropertyName}}[i] = ({{propertyInfo.PropertyTypeName}})other.{{propertyInfo.PropertyName}}[i]!.Clone();
                                }
                                else
                                {
                                    {{selfStatement}}.{{propertyInfo.PropertyName}}[i]!.MakeValueEqualTo(other.{{propertyInfo.PropertyName}}[i]!);
                                }
                    """
                : $"{selfStatement}.{propertyInfo.PropertyName}[i].MakeValueEqualTo(other.{propertyInfo.PropertyName}[i]);";
        
        // lang=cs
        var loop =
            $$"""
                    for (var i = 0; i < other.{{propertyInfo.PropertyName}}.Count; i++)
                    {
                        {{loopStatement}}
                    }
            """;
        
        stringBuilder.Append(loop);
        
        return stringBuilder.ToString();
    }
    
    private static string GenerateValueEqualsStatements(
        ImmutableArray<DocumentPropertyInfo> properties,
        string selfStatement)
    {
        if (properties.IsEmpty)
        {
            return "true";
        }

        var stringBuilder = new StringBuilder();

        for (var i = 0; i < properties.Length; i++)
        {
            if (i > 0)
            {
                stringBuilder.AppendLine(" &&");
                stringBuilder.Append("               ");
            }
            
            var propertyInfo = properties[i];
            var statement = propertyInfo.IsObservableCollection
                ? propertyInfo.IsValueTypeOrImmutableReference
                    ? $"global::System.Linq.Enumerable.SequenceEqual({selfStatement}.{propertyInfo.PropertyName}, other.{propertyInfo.PropertyName})"
                    : $"{selfStatement}.{propertyInfo.PropertyName}.SequenceValueEqual(other.{propertyInfo.PropertyName})"
                : propertyInfo.IsValueTypeOrImmutableReference
                    ? $"{selfStatement}.{propertyInfo.PropertyName}.Equals(other.{propertyInfo.PropertyName})"
                    : propertyInfo.IsNullableReferenceType
                        ? $"({selfStatement}.{propertyInfo.PropertyName}?.ValueEquals(other.{propertyInfo.PropertyName}) ?? other.{propertyInfo.PropertyName} is null)"
                        : $"{selfStatement}.{properties[i].PropertyName}.ValueEquals(other.{properties[i].PropertyName})";

            stringBuilder.Append(statement);
        }

        return stringBuilder.ToString();
    }
}