using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OpenTrackerNext.Roslyn.Semantic;
using OpenTrackerNext.Roslyn.SplatRegistration.Data;
using OpenTrackerNext.Roslyn.Syntactic;

namespace OpenTrackerNext.Roslyn.SplatRegistration;

/// <summary>
/// Generates the Splat type registration code.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class SplatRegistrationGenerator : IIncrementalGenerator
{
    /// <summary>
    /// The hint name of the generated file for the SplatAttribute.
    /// </summary>
    public const string SplatAttributeHintName = "OpenTrackerNext.SplatRegistration.SplatAttribute.g.cs";

    /// <summary>
    /// The hint name of the generated file for the SplatConstructorAttribute.
    /// </summary>
    public const string SplatConstructorAttributeHintName = "OpenTrackerNext.SplatRegistration.SplatConstructorAttribute.g.cs";

    /// <summary>
    /// The hint name of the generated file for the SplatGenericAttribute.
    /// </summary>
    public const string SplatGenericAttributeHintName = "OpenTrackerNext.SplatRegistration.SplatGenericAttribute.g.cs";

    /// <summary>
    /// The hint name of the generated file for the SplatIgnoreReactiveViewAttribute.
    /// </summary>
    public const string SplatIgnoreReactiveViewAttributeHintName = "OpenTrackerNext.SplatRegistration.SplatIgnoreReactiveViewAttribute.g.cs";

    /// <summary>
    /// The hint name of the generated file for the SplatSingleInstanceAttribute.
    /// </summary>
    public const string SplatSingleInstanceAttributeHintName = "OpenTrackerNext.SplatRegistration.SplatSingleInstanceAttribute.g.cs";

    /// <summary>
    /// The code for the SplatAttribute.
    /// </summary>
    // lang=cs
    public const string SplatAttributeCode =
        """
        // <auto-generated />
        #nullable enable
        
        namespace OpenTrackerNext.SplatRegistration;
        
        /// <summary>
        /// Marks a non-generic concrete class to be registered with Splat.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class SplatAttribute : global::System.Attribute
        {
            /// <summary>
            /// Gets a <see cref="global::System.Type"/> representing the concrete type to be registered.
            /// </summary>
            public global::System.Type? RegisterAsType { get; init; }
        }
        """;
    
    /// <summary>
    /// The code for the SplatGenericAttribute.
    /// </summary>
    // lang=cs
    public const string SplatConstructorAttributeCode =
        """
        // <auto-generated />
        #nullable enable
        
        namespace OpenTrackerNext.SplatRegistration;
        
        /// <summary>
        /// Marks a constructor to be used during Splat registration.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
        internal sealed class SplatConstructorAttribute : global::System.Attribute;
        """;
    
    /// <summary>
    /// The code for the SplatGenericAttribute.
    /// </summary>
    // lang=cs
    public const string SplatGenericAttributeCode =
        """
        // <auto-generated />
        #nullable enable
        
        namespace OpenTrackerNext.SplatRegistration;
        
        /// <summary>
        /// Marks a generic concrete class to be registered with Splat.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
        internal sealed class SplatGenericAttribute : global::System.Attribute
        {
            /// <summary>
            /// Gets a <see cref="global::System.Type"/> representing the concrete type to be registered.
            /// </summary>
            public required global::System.Type ConcreteType { get; init; }
            
            /// <summary>
            /// Gets a <see cref="global::System.Type"/> representing the type to be registered as.
            /// </summary>
            public global::System.Type? RegisterAsType { get; init; }
        }
        """;
    
    /// <summary>
    /// The code for the SplatIgnoreReactiveViewAttribute.
    /// </summary>
    // lang=cs
    public const string SplatIgnoreReactiveViewAttributeCode =
        """
        // <auto-generated />
        #nullable enable

        namespace OpenTrackerNext.SplatRegistration;

        /// <summary>
        /// Marks a ReactiveUI view class to be ignored by the source generator.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class SplatIgnoreReactiveViewAttribute : global::System.Attribute;
        """;
    
    /// <summary>
    /// The code for the SplatSingleInstanceAttribute.
    /// </summary>
    // lang=cs
    public const string SplatSingleInstanceAttributeCode =
        """
        // <auto-generated />
        #nullable enable

        namespace OpenTrackerNext.SplatRegistration;

        /// <summary>
        /// Marks a concrete class to be registered with Splat as a single instance.
        /// </summary>
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
        [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        internal sealed class SplatSingleInstanceAttribute : global::System.Attribute;
        """;

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(SplatAttributeHintName, SplatAttributeCode));
        
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(SplatConstructorAttributeHintName, SplatConstructorAttributeCode));
        
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(SplatGenericAttributeHintName, SplatGenericAttributeCode));
        
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(SplatIgnoreReactiveViewAttributeHintName, SplatIgnoreReactiveViewAttributeCode));
        
        context.RegisterPostInitializationOutput(
            ctx =>
                ctx.AddSource(SplatSingleInstanceAttributeHintName, SplatSingleInstanceAttributeCode));

        var viewForRegistrations = context.SyntaxProvider
            .CreateSyntaxProvider(
                CouldBeViewForClassDeclaration,
                TransformViewForClass)
            .Where(x => x is not null)
            .Collect();

        var nonGenericRegistrations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.SplatRegistration.SplatAttribute",
                CouldBeNonGenericMarkedClassDeclaration,
                TransformNonGenericMarkedClass)
            .Where(x => x is not null)
            .Collect();
        
        var genericRegistrations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "OpenTrackerNext.SplatRegistration.SplatGenericAttribute",
                CouldBeGenericMarkedClassDeclaration,
                TransformGenericMarkedClass)
            .Collect();

        var assemblyName = context.CompilationProvider
            .Select((x, _) => x.AssemblyName);

        var registrations = assemblyName
            .Combine(viewForRegistrations)
            .Combine(nonGenericRegistrations)
            .Combine(genericRegistrations)
            .Select(TransformRegistrations);
        
        context.RegisterSourceOutput(registrations, GenerateCode);
    }
    
    private static bool CouldBeViewForClassDeclaration(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsNotGeneric() &&
               classDeclaration.IsNotAbstract();
    }

    private static bool CouldBeNonGenericMarkedClassDeclaration(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsNotGeneric() &&
               classDeclaration.IsNotAbstract();
    }

    private static bool CouldBeGenericMarkedClassDeclaration(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.IsNotStatic() &&
               classDeclaration.IsGeneric() &&
               classDeclaration.IsNotAbstract();
    }

    private static SplatReactiveViewRegistrationInfo? TransformViewForClass(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        if (classSymbol.HasAttribute(
                out _,
                "SplatIgnoreReactiveViewAttribute",
                "OpenTrackerNext.SplatRegistration"))
        {
            return null;
        }

        if (!classSymbol.ImplementsInterfaceNamed(
                out var interfaceSymbol,
                "IViewFor",
                "ReactiveUI",
                1))
        {
            return null;
        }

        return new SplatReactiveViewRegistrationInfo(
            classSymbol.ToFullyQualifiedString(),
            interfaceSymbol.ToFullyQualifiedString());
    }
    
    private static SplatRegistrationInfo? TransformNonGenericMarkedClass(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;
        var attributeData = context.Attributes[0];

        var singleInstance = classSymbol
            .HasAttribute(
                out _,
                "SplatSingleInstanceAttribute",
                "OpenTrackerNext.SplatRegistration");

        INamedTypeSymbol? registerAsTypeSymbol = null;
        
        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var namedArgument in attributeData.NamedArguments)
        {
            if (namedArgument.Key == "RegisterAsType")
            {
                registerAsTypeSymbol = (INamedTypeSymbol)namedArgument.Value.Value!;
            }
        }
        
        registerAsTypeSymbol ??= classSymbol;

        return CreateRegistrationInfo(classSymbol, registerAsTypeSymbol, singleInstance);
    }
    
    private static ImmutableArray<SplatRegistrationInfo> TransformGenericMarkedClass(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;
        var attributes = context.Attributes;

        var singleInstance = classSymbol
            .HasAttribute(
                out _,
                "SplatSingleInstanceAttribute",
                "OpenTrackerNext.SplatRegistration");

        var builder = ImmutableArray.CreateBuilder<SplatRegistrationInfo>();

        foreach (var attribute in attributes)
        {
            INamedTypeSymbol? concreteTypeSymbol = null;
            INamedTypeSymbol? registerAsTypeSymbol = null;
            foreach (var namedArgument in attribute.NamedArguments)
            {
                switch (namedArgument.Key)
                {
                    case "ConcreteType":
                        concreteTypeSymbol = (INamedTypeSymbol)namedArgument.Value.Value!;
                        break;
                    case "RegisterAsType":
                        registerAsTypeSymbol = (INamedTypeSymbol)namedArgument.Value.Value!;
                        break;
                }
            }

            if (concreteTypeSymbol is null)
            {
                continue;
            }
            
            registerAsTypeSymbol ??= concreteTypeSymbol;

            if (registerAsTypeSymbol.IsUnboundGenericType)
            {
                continue;
            }

            var registrationInfo = CreateRegistrationInfo(
                concreteTypeSymbol,
                registerAsTypeSymbol,
                singleInstance);

            if (registrationInfo is not null)
            {
                builder.Add(registrationInfo.Value);
            }
        }

        return builder.ToImmutable();
    }

    private static SplatRegistrationInfo? CreateRegistrationInfo(
        INamedTypeSymbol concreteTypeSymbol,
        INamedTypeSymbol registerAsTypeSymbol,
        bool singleInstance)
    {
        var registerAsTypeIsDelegate = registerAsTypeSymbol.TypeKind == TypeKind.Delegate;

        if (registerAsTypeSymbol.IsUnboundGenericType)
        {
            return null;
        }

        switch (registerAsTypeIsDelegate)
        {
            case false when
                !SymbolEqualityComparer.Default.Equals(registerAsTypeSymbol, concreteTypeSymbol) &&
                !concreteTypeSymbol.InheritsFromOrImplements(registerAsTypeSymbol):
                return null;
            case true:
                if (singleInstance)
                {
                    return null;
                }

                if (registerAsTypeSymbol.DelegateInvokeMethod?.ReturnType is not INamedTypeSymbol returnType)
                {
                    return null;
                }

                if (returnType.IsUnboundGenericType)
                {
                    return null;
                }
                
                if (!SymbolEqualityComparer.Default.Equals(returnType, concreteTypeSymbol) &&
                    !concreteTypeSymbol.InheritsFromOrImplements(returnType))
                {
                    return null;
                }
                
                break;
        }

        var constructorParameters = GetConstructorParameters(concreteTypeSymbol);
        var delegateParameters = registerAsTypeIsDelegate
            ? GetDelegateParameters(registerAsTypeSymbol)
            : ImmutableArray<SplatParameterInfo>.Empty;
        
        if (constructorParameters is null)
        {
            return null;
        }
        
        if (delegateParameters is null)
        {
            return null;
        }

        return new SplatRegistrationInfo(
            concreteTypeSymbol.ToFullyQualifiedString(),
            registerAsTypeSymbol.ToFullyQualifiedString(),
            singleInstance,
            registerAsTypeIsDelegate,
            constructorParameters.Value,
            delegateParameters.Value);
    }
    
    private static ImmutableArray<SplatParameterInfo>? GetConstructorParameters(INamedTypeSymbol classSymbol)
    {
        if (classSymbol.Constructors.Length == 0)
        {
            return ImmutableArray<SplatParameterInfo>.Empty;
        }

        var builder = ImmutableArray.CreateBuilder<SplatParameterInfo>();
        var constructor = GetConstructor(classSymbol);
        
        if (constructor is null)
        {
            return null;
        }
        
        foreach (var parameter in constructor.Parameters)
        {
            builder.Add(
                new SplatParameterInfo(
                    parameter.Type.ToFullyQualifiedString(),
                    parameter.Name,
                    parameter.NullableAnnotation == NullableAnnotation.Annotated));
        }
        
        return builder.ToImmutable();
    }

    private static IMethodSymbol? GetConstructor(INamedTypeSymbol classSymbol)
    {
        if (classSymbol.Constructors.Length == 1)
        {
            return classSymbol.Constructors[0];
        }

        var markedConstructors = new List<IMethodSymbol>();
        
        // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
        foreach (var constructor in classSymbol.Constructors)
        {
            if (constructor.HasAttribute(
                    out _,
                    "SplatConstructorAttribute",
                    "OpenTrackerNext.SplatRegistration"))
            {
                markedConstructors.Add(constructor);
            }
        }
        
        return markedConstructors.Count == 1 ? markedConstructors[0] : null;
    }
    
    private static ImmutableArray<SplatParameterInfo>? GetDelegateParameters(INamedTypeSymbol registerAsTypeSymbol)
    {
        var delegateSymbol = registerAsTypeSymbol.DelegateInvokeMethod;

        if (delegateSymbol is null)
        {
            return null;
        }
        
        var builder = ImmutableArray.CreateBuilder<SplatParameterInfo>();
        
        foreach (var parameter in delegateSymbol.Parameters)
        {
            builder.Add(
                new SplatParameterInfo(
                    parameter.Type.ToFullyQualifiedString(),
                    parameter.Name,
                    parameter.NullableAnnotation == NullableAnnotation.Annotated));
        }
        
        return builder.ToImmutable();
    }
    
    private static SplatRegistrations TransformRegistrations(
        (((string? Left, ImmutableArray<SplatReactiveViewRegistrationInfo?> Right) Left,
            ImmutableArray<SplatRegistrationInfo?> Right) Left,
            ImmutableArray<ImmutableArray<SplatRegistrationInfo>> Right) registrations,
        CancellationToken cancellationToken)
    {
        return new SplatRegistrations(
            registrations.Left.Left.Left,
            registrations.Left.Left.Right,
            registrations.Left.Right,
            registrations.Right);
    }
    
    private static void GenerateCode(SourceProductionContext context, SplatRegistrations registrations)
    {
        var assemblyNameWithoutPeriods = registrations.AssemblyName!.Replace(".", string.Empty);
        
        // lang=cs
        var header =
            $$"""
            // <auto-generated/>
            #nullable enable
            
            namespace {{registrations.AssemblyName}}.Generated;
            
            public static partial class SplatExtensions
            {
                public static global::Splat.IMutableDependencyResolver RegisterTypesFrom{{assemblyNameWithoutPeriods}}(this global::Splat.IMutableDependencyResolver resolver)
                {
            
            """;

        var stringBuilder = new StringBuilder(header);
        
        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var registration in registrations.ReactiveViewRegistrations)
        {
            if (registration is null)
            {
                continue;
            }
            
            // lang=cs
            stringBuilder
                .AppendLine(
                    $"        resolver.Register(() => new {registration.Value.TypeName}(), typeof({registration.Value.RegisterAsTypeName}));");
        }
        
        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var registration in registrations.NonGenericRegistrations)
        {
            if (registration is null)
            {
                continue;
            }

            GenerateRegistration(stringBuilder, registration.Value);
        }

        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var genericRegistrations in registrations.GenericRegistrations)
        {
            foreach (var registration in genericRegistrations)
            {
                GenerateRegistration(stringBuilder, registration);
            }
        }
        
        // lang=cs
        const string footer =
            """
                    return resolver;
                }
            }
            """;
        
        stringBuilder.Append(footer);
        
        context.AddSource(
            $"{registrations.AssemblyName}.Generated.SplatExtensions.g.cs",
            stringBuilder.ToString());
    }

    private static void GenerateRegistration(StringBuilder stringBuilder, SplatRegistrationInfo registration)
    {
        if (registration.IsDelegate)
        {
            GenerateDelegateRegistration(stringBuilder, registration);
            return;
        }

        if (registration.IsSingleInstance)
        {
            GenerateSingleInstanceRegistration(stringBuilder, registration);
            return;
        }
        
        GenerateTransientRegistration(stringBuilder, registration);
    }
    
    private static void GenerateDelegateRegistration(StringBuilder stringBuilder, SplatRegistrationInfo registration)
    {
        var delegateTypeName = registration.RegisterAsTypeName;
        var delegateParameters = GeneratorDelegateParameters(registration);
        var concreteTypeName = registration.ConcreteTypeName;
        var constructorArguments = GenerateDelegateConstructorArgument(registration);
        
        // lang=cs
        stringBuilder
            .AppendLine(
                $"        resolver.Register(() => new {delegateTypeName}(({delegateParameters}) => new {concreteTypeName}({constructorArguments})), typeof({registration.RegisterAsTypeName}));");
    }
    
    private static void GenerateSingleInstanceRegistration(
        StringBuilder stringBuilder,
        SplatRegistrationInfo registration)
    {
        var concreteTypeName = registration.ConcreteTypeName;
        var constructorArguments = GenerateConstructorArguments(registration);
        var registerAsTypeName = registration.RegisterAsTypeName;
        
        // lang=cs
        var registrationString =
            $$"""
                    {
                        var lazy = new global::System.Lazy<{{registerAsTypeName}}>(() => new {{concreteTypeName}}({{constructorArguments}}));
                        resolver.Register(() => lazy, typeof(global::System.Lazy<{{registerAsTypeName}}>));
                        resolver.Register(() => lazy.Value, typeof({{registerAsTypeName}}));
                    }
            """;

        stringBuilder.AppendLine(registrationString);
    }
    
    private static void GenerateTransientRegistration(StringBuilder stringBuilder, SplatRegistrationInfo registration)
    {
        var concreteTypeName = registration.ConcreteTypeName;
        var constructorArguments = GenerateConstructorArguments(registration);
        var registerAsTypeName = registration.RegisterAsTypeName;
        
        // lang=cs
        stringBuilder
            .AppendLine(
                $"        resolver.Register(() => new {concreteTypeName}({constructorArguments}), typeof({registerAsTypeName}));");
    }
    
    private static string GeneratorDelegateParameters(SplatRegistrationInfo registration)
    {
        return string.Join(
            ", ",
            registration.DelegateParameters
                .Select(x => x.ParameterName));
    }

    private static string GenerateDelegateConstructorArgument(SplatRegistrationInfo registration)
    {
        return string
            .Join(
                ", ",
                registration.ConstructorParameters
                    .Select(
                        x =>
                            registration.DelegateParameters.Any(y => x == y)
                                ? x.ParameterName
                                : $"({x.TypeName})global::Splat.Locator.Current.GetService(typeof({x.TypeName})){(x.IsNullable ? string.Empty : "!")}"));
    }
    
    private static string GenerateConstructorArguments(SplatRegistrationInfo registration)
    {
        return string
            .Join(
                ", ",
                registration.ConstructorParameters
                    .Select(
                        x =>
                            $"({x.TypeName})global::Splat.Locator.Current.GetService(typeof({x.TypeName})){(x.IsNullable ? string.Empty : "!")}"));
    }
}